#!/usr/bin/env bash
# Mock Claude executable for ralph integration tests
# Reads scenario file from MOCK_SCENARIO and executes the appropriate phase
# Outputs in stream-json format that ralph expects
set -euo pipefail

SCENARIO_FILE="${MOCK_SCENARIO:-}"
PROMPT="$*"

# Debug output (only if RALPH_DEBUG is set)
if [ "${RALPH_DEBUG:-0}" = "1" ]; then
  echo "[mock-claude] Scenario: ${SCENARIO_FILE:-<none>}" >&2
  echo "[mock-claude] Prompt length: ${#PROMPT}" >&2
fi

# Helper: output text in stream-json format
# Usage: stream_text "your message"
stream_text() {
  local text="$1"
  # Escape for JSON (handle newlines, quotes, backslashes)
  local escaped
  escaped=$(echo "$text" | jq -Rs '.')
  # Output as assistant message with text content
  echo "{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":$escaped}]}}"
}

# Helper: output final result in stream-json format
# Usage: stream_result "final output text"
stream_result() {
  local text="$1"
  local escaped
  escaped=$(echo "$text" | jq -Rs '.')
  echo "{\"type\":\"result\",\"result\":$escaped,\"cost_usd\":0,\"usage\":{\"input_tokens\":100,\"output_tokens\":50},\"duration_ms\":1000}"
}

# If no scenario, just echo the prompt and exit
if [ -z "$SCENARIO_FILE" ]; then
  stream_text "[mock-claude] No scenario file specified (MOCK_SCENARIO)"
  stream_result "[mock-claude] Prompt received"
  exit 0
fi

# Check scenario file exists
if [ ! -f "$SCENARIO_FILE" ]; then
  echo "[mock-claude] ERROR: Scenario file not found: $SCENARIO_FILE" >&2
  exit 1
fi

# Check if scenario is JSON or shell
IS_JSON_SCENARIO=0
if [[ "$SCENARIO_FILE" == *.json ]]; then
  IS_JSON_SCENARIO=1
else
  # Source the shell scenario file
  # shellcheck source=/dev/null
  source "$SCENARIO_FILE"
fi

# Execute JSON scenario phase
# Usage: exec_json_phase <phase>
exec_json_phase() {
  local phase="$1"
  local work_msg done_msg signal

  # Extract phase data using jq
  work_msg=$(jq -r ".phases.${phase}.messages.work // \"\"" "$SCENARIO_FILE")
  done_msg=$(jq -r ".phases.${phase}.messages.done // \"\"" "$SCENARIO_FILE")
  signal=$(jq -r ".phases.${phase}.signal // \"\"" "$SCENARIO_FILE")

  # Output messages (|| true prevents set -e failure on empty)
  [ -n "$work_msg" ] && echo "$work_msg" || true
  [ -n "$done_msg" ] && echo "$done_msg" || true
  # Output signal (null becomes "null" string via jq -r, skip if empty or "null")
  if [ -n "$signal" ] && [ "$signal" != "null" ]; then
    echo "$signal"
  fi
}

# Detect phase from prompt content
detect_phase() {
  local prompt="$1"

  # Check for step phase markers FIRST (most specific)
  # Matches: "# Implementation Step" (the heading), "## Issue Details", "step.md"
  # Note: Use more specific patterns to avoid matching "each implementation step" in ready.md
  if echo "$prompt" | grep -qE "^# Implementation Step|^## Issue Details|step\.md"; then
    echo "step"
    return
  fi

  # Check for ready phase markers
  # Matches: "Convert Spec to Tasks", "task breakdown", "create task beads", "ready.md"
  if echo "$prompt" | grep -qiE "convert.spec|task.breakdown|create.task.bead|ready\.md"; then
    echo "ready"
    return
  fi

  # Check for plan phase markers
  # Matches: "Specification Interview", "spec interview", "plan.md"
  # Note: Removed "create.*spec" as it false-positives on step template's "bd create --labels=spec-"
  if echo "$prompt" | grep -qiE "specification.interview|spec.interview|plan\.md"; then
    echo "plan"
    return
  fi

  # Default to step (most common)
  echo "step"
}

PHASE=$(detect_phase "$PROMPT")

if [ "${RALPH_DEBUG:-0}" = "1" ]; then
  echo "[mock-claude] Detected phase: $PHASE" >&2
fi

# Capture the phase function output
PHASE_OUTPUT=""
if [ "$IS_JSON_SCENARIO" = "1" ]; then
  # JSON scenario: use exec_json_phase
  PHASE_OUTPUT=$(exec_json_phase "$PHASE")
else
  # Shell scenario: use phase_* functions
  case "$PHASE" in
    plan)
      if type phase_plan &>/dev/null; then
        PHASE_OUTPUT=$(phase_plan)
      else
        PHASE_OUTPUT="[mock-claude] No phase_plan function defined"
      fi
      ;;
    ready)
      if type phase_ready &>/dev/null; then
        PHASE_OUTPUT=$(phase_ready)
      else
        PHASE_OUTPUT="[mock-claude] No phase_ready function defined"
      fi
      ;;
    step)
      if type phase_step &>/dev/null; then
        PHASE_OUTPUT=$(phase_step)
      else
        PHASE_OUTPUT="[mock-claude] No phase_step function defined"
      fi
      ;;
    *)
      PHASE_OUTPUT="[mock-claude] Unknown phase: $PHASE"
      ;;
  esac
fi

# Output the phase result in stream-json format
# First, output any intermediate text (everything except RALPH_* signals)
NON_SIGNAL_OUTPUT=$(echo "$PHASE_OUTPUT" | grep -v "^RALPH_" || true)
if [ -n "$NON_SIGNAL_OUTPUT" ]; then
  stream_text "$NON_SIGNAL_OUTPUT"
fi

# Then output the result (including any RALPH_* signals)
stream_result "$PHASE_OUTPUT"
