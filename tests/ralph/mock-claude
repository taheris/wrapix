#!/usr/bin/env bash
# Mock Claude executable for ralph integration tests
# Reads scenario file from MOCK_SCENARIO and executes the appropriate phase
# Outputs in stream-json format that ralph expects
set -euo pipefail

SCENARIO_FILE="${MOCK_SCENARIO:-}"
PROMPT="$*"

# Debug output (only if RALPH_DEBUG is set)
if [ "${RALPH_DEBUG:-0}" = "1" ]; then
  echo "[mock-claude] Scenario: ${SCENARIO_FILE:-<none>}" >&2
  echo "[mock-claude] Prompt length: ${#PROMPT}" >&2
fi

# Helper: output text in stream-json format
# Usage: stream_text "your message"
stream_text() {
  local text="$1"
  # Escape for JSON (handle newlines, quotes, backslashes)
  local escaped
  escaped=$(echo "$text" | jq -Rs '.')
  # Output as assistant message with text content
  echo "{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"text\",\"text\":$escaped}]}}"
}

# Helper: output final result in stream-json format
# Usage: stream_result "final output text"
stream_result() {
  local text="$1"
  local escaped
  escaped=$(echo "$text" | jq -Rs '.')
  echo "{\"type\":\"result\",\"result\":$escaped,\"cost_usd\":0,\"usage\":{\"input_tokens\":100,\"output_tokens\":50},\"duration_ms\":1000}"
}

# If no scenario, just echo the prompt and exit
if [ -z "$SCENARIO_FILE" ]; then
  stream_text "[mock-claude] No scenario file specified (MOCK_SCENARIO)"
  stream_result "[mock-claude] Prompt received"
  exit 0
fi

# Check scenario file exists
if [ ! -f "$SCENARIO_FILE" ]; then
  echo "[mock-claude] ERROR: Scenario file not found: $SCENARIO_FILE" >&2
  exit 1
fi

# Source the scenario file
# shellcheck source=/dev/null
source "$SCENARIO_FILE"

# Detect phase from prompt content
detect_phase() {
  local prompt="$1"

  # Check for plan phase markers
  # Matches: "Specification Interview", "spec interview", "create a spec", "plan"
  if echo "$prompt" | grep -qiE "specification.interview|spec.interview|create.*spec|plan\.md"; then
    echo "plan"
    return
  fi

  # Check for ready phase markers
  # Matches: "Convert Spec to Tasks", "task breakdown", "ready.md"
  if echo "$prompt" | grep -qiE "convert.spec|create.*task|task.breakdown|ready\.md"; then
    echo "ready"
    return
  fi

  # Check for step phase markers (implementation)
  # Matches: "Implementation Step", "Issue Details", "step.md"
  if echo "$prompt" | grep -qiE "implementation|issue.details|step\.md"; then
    echo "step"
    return
  fi

  # Default to step (most common)
  echo "step"
}

PHASE=$(detect_phase "$PROMPT")

if [ "${RALPH_DEBUG:-0}" = "1" ]; then
  echo "[mock-claude] Detected phase: $PHASE" >&2
fi

# Capture the phase function output
PHASE_OUTPUT=""
case "$PHASE" in
  plan)
    if type phase_plan &>/dev/null; then
      PHASE_OUTPUT=$(phase_plan)
    else
      PHASE_OUTPUT="[mock-claude] No phase_plan function defined"
    fi
    ;;
  ready)
    if type phase_ready &>/dev/null; then
      PHASE_OUTPUT=$(phase_ready)
    else
      PHASE_OUTPUT="[mock-claude] No phase_ready function defined"
    fi
    ;;
  step)
    if type phase_step &>/dev/null; then
      PHASE_OUTPUT=$(phase_step)
    else
      PHASE_OUTPUT="[mock-claude] No phase_step function defined"
    fi
    ;;
  *)
    PHASE_OUTPUT="[mock-claude] Unknown phase: $PHASE"
    ;;
esac

# Output the phase result in stream-json format
# First, output any intermediate text (everything except RALPH_* signals)
NON_SIGNAL_OUTPUT=$(echo "$PHASE_OUTPUT" | grep -v "^RALPH_" || true)
if [ -n "$NON_SIGNAL_OUTPUT" ]; then
  stream_text "$NON_SIGNAL_OUTPUT"
fi

# Then output the result (including any RALPH_* signals)
stream_result "$PHASE_OUTPUT"
