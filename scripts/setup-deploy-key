#!/usr/bin/env bash
#
# Setup a deploy key for secure git push from sandboxed environments.
# Must be run from within a git repository with a GitHub remote.
#
# Security note: Keys are generated without passphrases to enable
# non-interactive use by AI agents. See specs/security-review.md
# for the security tradeoff discussion and mitigations.
#
# Usage: setup-deploy-key [keyname] [-f|--force]
#

set -euo pipefail

die() { echo "error: $*" >&2; exit 1; }

# Parse arguments
FORCE=false
KEYNAME=""

for arg in "$@"; do
    case $arg in
        -h|--help)
            echo "Usage: setup-deploy-key [keyname] [-f|--force]"
            echo "  keyname: Name for the deploy key (default: repo-hostname)"
            echo "  -f:      Overwrite existing key"
            exit 0
            ;;
        -f|--force) FORCE=true ;;
        -*) die "unknown option: $arg" ;;
        *) [[ -z "$KEYNAME" ]] || die "unexpected argument: $arg"; KEYNAME="$arg" ;;
    esac
done

# Must be in a git repo with GitHub origin
[[ -d .git ]] || die "not in a git repository"
ORIGIN_URL=$(git remote get-url origin 2>/dev/null) || die "no origin remote found"
[[ "$ORIGIN_URL" =~ github\.com[:/]([^/]+/[^/.]+)(\.git)?$ ]] || die "not a GitHub repo: $ORIGIN_URL"
REPO="${BASH_REMATCH[1]}"
HOSTNAME=$(hostname -s 2>/dev/null || hostname)
KEYNAME="${KEYNAME:-${REPO#*/}-${HOSTNAME}}"

# Check dependencies
command -v gh >/dev/null || die "gh CLI required"
command -v ssh-keygen >/dev/null || die "ssh-keygen required"
gh auth status >/dev/null 2>&1 || die "run 'gh auth login' first"

KEY_DIR="$HOME/.ssh/deploy_keys"
KEY_PATH="$KEY_DIR/${KEYNAME}"
SIGNING_KEY_PATH="$KEY_DIR/${KEYNAME}-signing"

echo "Setting up deploy key '$KEYNAME' for $REPO"

# Generate deploy key pair
if [[ -f "$KEY_PATH" ]]; then
    [[ "$FORCE" == true ]] || die "key exists: $KEY_PATH (use -f to overwrite)"
    rm -f "$KEY_PATH" "$KEY_PATH.pub"
fi
mkdir -p "$KEY_DIR" && chmod 700 "$KEY_DIR"
ssh-keygen -t ed25519 -f "$KEY_PATH" -N "" -C "deploy-key-${KEYNAME}" >/dev/null
chmod 600 "$KEY_PATH" && chmod 644 "$KEY_PATH.pub"

# Generate separate signing key pair (GitHub doesn't allow same key for deploy and signing)
if [[ -f "$SIGNING_KEY_PATH" ]]; then
    [[ "$FORCE" == true ]] || die "signing key exists: $SIGNING_KEY_PATH (use -f to overwrite)"
    rm -f "$SIGNING_KEY_PATH" "$SIGNING_KEY_PATH.pub"
fi
ssh-keygen -t ed25519 -f "$SIGNING_KEY_PATH" -N "" -C "signing-key-${KEYNAME}" >/dev/null
chmod 600 "$SIGNING_KEY_PATH" && chmod 644 "$SIGNING_KEY_PATH.pub"

# Add to GitHub
EXISTING_ID=$(gh repo deploy-key list -R "$REPO" --json id,title \
    | jq -r ".[] | select(.title == \"$KEYNAME\") | .id" 2>/dev/null || true)
if [[ -n "$EXISTING_ID" ]]; then
    [[ "$FORCE" == true ]] || die "deploy key '$KEYNAME' exists on GitHub (use -f to overwrite)"
    gh repo deploy-key delete "$EXISTING_ID" -R "$REPO"
fi
gh repo deploy-key add "$KEY_PATH.pub" -R "$REPO" -t "$KEYNAME" -w

# Add to user's signing keys for commit verification on GitHub
# Requires admin:ssh_signing_key scope - prompt user to add if missing
SIGNING_KEY_TITLE="signing-$KEYNAME"

# Find existing signing key by title (not fingerprint - that changes when key is regenerated)
EXISTING_SIGNING_KEY=$(gh api /user/ssh_signing_keys --jq ".[] | select(.title == \"$SIGNING_KEY_TITLE\") | .id" 2>/dev/null || true)

if [[ -n "$EXISTING_SIGNING_KEY" ]]; then
    if [[ "$FORCE" == true ]]; then
        if gh api -X DELETE "/user/ssh_signing_keys/$EXISTING_SIGNING_KEY" 2>/dev/null; then
            echo -e "\033[31m✓\033[0m Signing key deleted from GitHub"
        else
            die "Could not delete existing signing key (run: gh auth refresh -s admin:ssh_signing_key)"
        fi
    else
        echo "Signing key '$SIGNING_KEY_TITLE' already exists on GitHub (use -f to update)"
        echo "Done! Key: $KEY_PATH"
        exit 0
    fi
fi

# Add the new signing key
if ADD_OUTPUT=$(gh ssh-key add "$SIGNING_KEY_PATH.pub" --title "$SIGNING_KEY_TITLE" --type signing 2>&1); then
    echo -e "\033[32m✓\033[0m Signing key added to your GitHub account"
else
    if echo "$ADD_OUTPUT" | grep -q "already in use"; then
        die "Signing key already in use (this shouldn't happen with a fresh key)"
    elif echo "$ADD_OUTPUT" | grep -qi "scope\|ssh_signing_key\|permission"; then
        echo ""
        die "Missing permission. Run: gh auth refresh -s admin:ssh_signing_key && $0 $KEYNAME -f"
    else
        die "Could not add signing key: $ADD_OUTPUT"
    fi
fi

echo "Done!"
echo "  Deploy key: $KEY_PATH"
echo "  Signing key: $SIGNING_KEY_PATH"
